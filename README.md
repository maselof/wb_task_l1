# WB_TECH_L1  
1. Какой самый эффективный способ конкатенации строк?
     
Я знаю три способа конкатенации строк. Это через байты, с помощью функции copy и используя структуру Buffer в пакете bytes. Но самый быстрый способ появился с версии 1.10, это использование strings.Builder. Пример использования:  
```golang
package main
  
import (  
	"fmt"  
	"log"  
	"strings"  
)  
  
func main() {  
	var b strings.Builder  
	b.Grow(5) // Указывается значение capacity  
	for i := 0; i < 5; i++ {  
		fmt.Fprintf(&b, "%d ", i) // Запихиваем значение в b  
	}  
	s := b.String()                      // Конвертируем значение в string. При этом оно не копируется.  
	log.Println(fmt.Sprintf("%T", s), s) // Вывод данных  
}
```
2. Что такое интерфейсы, как они применяются в Go?
  
Проще говоря, интерфейс — это абстрактный тип, определяющий множество функций, которые необходимо реализовать для типа, чтобы его можно
было считать экземпляром интерфейса.  
Интерфейсы в Go используются по большей части для полиформизма. Так как такого ООП в Golang нет. Также используются для перегрузки методов.  

3. Чем отличаются RWMutex от Mutex?
   
RWMutex это всё тот же Mutex, только он позволяет получать эксклюзивные блокировки отдельно на чтение и отдельно — на запись.  

4. Чем отличаются буферизированные и не буферизированные каналы?  

Буфферизированные каналы имеет емкость передаваемых данных, канал-отправитель ждет, когда освободится место для передаваемого значения, если канал полн. А небуфферизированные имеет емкость 1.  

5. Какой размер у структуры struct{}{}?

0 байт.  

6. Есть ли в Go перегрузка методов или операторов?

Перегрузки операторов нет. А вот перегрузки методов достигается с помощью интерфейсов.  

7. В какой последовательности будут выведены элементы map[int]int?

Последовательность, в которой выведет данные значения недетерминирован.

8. В чем разница make и new?

make используется только для slice, map, chan, когда new для любой структуры. New возвращает указатель типа, когда make возвращает сам тип. Make позволяет указать размерность, а new нет. New выделяет место без инициализации, а make с инициализацией.
  
9. Сколько существует способов задать переменную типа slice или map?

Три способа: с помозью функции make, инициализации и объявлении переменной, но в этом способе не будет инициализации, мы просто объявляем переменную.  
```golang
valMap := make(map[string]int)
valMap := map[string]int{"a": 1, "b": 2}
var valMap map[int]string
```
  
10. Что выведет данная программа и почему?
```golang
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
Программа выведет две 1, так как в функцию update он копирует p, а не ссылается на неё.  

11. Что выведет данная программа и почему?
```golang
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```  
Программа выведет ошибку deadlock, так как переменная wg передается копией, и никак не уменьшается счетчик в главной горутине.  

12. Что выведет данная программа и почему?
```golang
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
Выведет 0, так как переменная n в if находится в другой области видимости и не повлияет на внешнюю n.  

13. Что выведет данная программа и почему?
```golang
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
[100, 2, 3, 4 ,5]  
Функция поменяет только 0 индекс слайса, так как под слайсом лежит обычный массив, на который он ссылается. Но когда мы сделаем append, он создает массив два раза больше и начинает ссылаться на него. Но в главной горутине, он не передает ссылку, поэтому append не сработает.  

14. Что выведет данная программа и почему?
```golang
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```  
[b b a][a a]  
Так как выполняется сначала append, то slice в анонимной функции начнет ссылаться на другой массив в памяти, при этом внешний slice не будет меняться.
